name: CI Pipeline

on:
  push:
    branches: [dev, staging]
  pull_request:
    branches: [dev, staging, release]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  security-events: write
  actions: read
  id-token: write

env:
  NODE_VERSION: '20.x'

jobs:
  # ============================================
  # Change detection to skip CI on non-code edits
  # ============================================
  changes:
    name: Detect code changes
    runs-on: ubuntu-latest
    outputs:
      code: ${{ steps.filter.outputs.code }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changes vs origin/dev
        id: filter
        run: |
          # Only run change detection on dev branch pushes
          if [[ "$GITHUB_REF" == "refs/heads/dev" ]]; then
            git fetch origin dev --no-tags 2>/dev/null || true
            
            # Compare incoming commits vs origin/dev
            CHANGED_FILES=$(git diff --name-only origin/dev...HEAD 2>/dev/null || echo "")
            
            # Check if any code files changed
            CODE_CHANGED=false
            for file in $CHANGED_FILES; do
              if [[ $file =~ ^(src/|scripts/|resources/|embeds/|package|tsconfig|jest.config|\.github/workflows/) ]]; then
                CODE_CHANGED=true
                break
              fi
            done
            
            echo "code=$CODE_CHANGED" >> $GITHUB_OUTPUT
            echo "Changed files: $CHANGED_FILES"
          else
            # For staging/other branches, assume code changed (skip detection)
            echo "code=true" >> $GITHUB_OUTPUT
            echo "Skipping change detection on $GITHUB_REF"
          fi

  # ============================================
  # Stage 1: Build & Test (runs on all platforms)
  # Skipped on staging push - dev already validated
  # ============================================
  build-and-test:
    name: Build & Test (${{ matrix.os }}, Node ${{ matrix.node }})
    needs: changes
    if: needs.changes.outputs.code == 'true' && (github.ref != 'refs/heads/staging' || github.event_name == 'pull_request')
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest]
        node: ['20.x']

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Verify embeddings are current
        shell: bash
        run: |
          echo "Running embedding scripts to ensure latest content..."
          npm run embed-all
          
          # Check if embeddings changed
          if git diff --quiet; then
            echo "✅ Embeddings are up-to-date"
          else
            echo "::error::Embeddings are out-of-date! Run 'npm run embed-all' locally before pushing."
            echo "Modified files:"
            git diff --name-only
            exit 1
          fi

      - name: TypeScript Compilation Check
        shell: bash
        run: |
          if ! npx tsc --noEmit; then
            echo "::error::TypeScript compilation failed"
            exit 1
          fi
          echo "✅ TypeScript compilation successful"

      - name: Compile TypeScript
        run: npm run compile

      - name: Run unit tests with coverage
        run: npm run test:coverage

      - name: Upload coverage (Ubuntu/Node 20 only)
        uses: codecov/codecov-action@v4
        if: matrix.os == 'ubuntu-latest' && matrix.node == '20.x'
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage/coverage-final.json
          flags: unittests
          fail_ci_if_error: false

      - name: Run E2E tests (Linux)
        if: runner.os == 'Linux'
        run: xvfb-run -a npm run test:e2e

      - name: Run E2E tests (Windows/macOS)
        if: runner.os != 'Linux'
        run: npm run test:e2e

      - name: Build VSIX package
        if: matrix.os == 'ubuntu-latest' && matrix.node == '20.x'
        run: npm run package:vsix

      - name: Upload VSIX artifact
        uses: actions/upload-artifact@v4
        if: matrix.os == 'ubuntu-latest' && matrix.node == '20.x'
        with:
          name: vsix-main
          path: 'vsix/ai-skeleton-extension-*.vsix'
          retention-days: 30

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: matrix.os == 'ubuntu-latest' && matrix.node == '20.x'
        with:
          name: test-results
          path: coverage/
          retention-days: 7

  # ============================================
  # Stage 1 (parallel): Security Analysis
  # ============================================
  security:
    name: CodeQL Security Analysis
    needs: changes
    if: needs.changes.outputs.code == 'true' && (github.ref != 'refs/heads/staging' || github.event_name == 'pull_request')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: javascript

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          category: "/language:javascript"

  # ============================================
  # Stage 2: Smoke Test VSIX (after build passes on dev)
  # ============================================
  smoke-test:
    name: Smoke Test VSIX
    needs: [changes, build-and-test]
    if: needs.changes.outputs.code == 'true' && (github.ref != 'refs/heads/staging' || github.event_name == 'pull_request')
    runs-on: ubuntu-latest
    steps:
      - name: Download VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: vsix-main

      - name: Verify VSIX package
        run: |
          # Find the main extension VSIX (not prompts)
          VSIX_FILE=$(ls ai-skeleton-extension-*.vsix 2>/dev/null | head -1)
          if [ -z "$VSIX_FILE" ]; then
            echo "::error::VSIX file not found!"
            exit 1
          fi
          echo "✅ VSIX package found: $VSIX_FILE"
          
          # Basic integrity check
          if ! unzip -t "$VSIX_FILE" > /dev/null 2>&1; then
            echo "::error::VSIX archive is corrupted"
            exit 1
          fi
          echo "✅ VSIX integrity verified"

  # ============================================
  # Stage 3: Auto-merge to Staging (dev branch only)
  # ============================================
  auto-merge-staging:
    name: Auto-merge to Staging
    needs: [changes, build-and-test, security, smoke-test]
    if: needs.changes.outputs.code == 'true' && github.ref == 'refs/heads/dev' && github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      merged: ${{ steps.merge.outputs.merged }}
      version: ${{ steps.version.outputs.version }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download VSIX artifact
        uses: actions/download-artifact@v4
        with:
          name: vsix-main
          path: ./vsix-artifact

      - name: Download test results
        uses: actions/download-artifact@v4
        with:
          name: test-results
          path: ./test-results

      - name: Verify artifacts exist
        run: |
          if [ ! -f ./vsix-artifact/*.vsix ]; then
            echo "::error::VSIX artifact missing - cannot merge to staging"
            exit 1
          fi
          echo "✅ All required artifacts present"

      - name: Get current version
        id: version
        run: |
          VERSION=$(jq -r '.version' package.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Merge dev to staging
        id: merge
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git checkout staging
          
          # Try fast-forward merge first, fall back to squash
          if git merge --ff-only origin/dev 2>/dev/null; then
            echo "✅ Fast-forward merge successful"
          else
            git merge --squash origin/dev
            if git diff-index --quiet HEAD --; then
              echo "No changes to merge"
              echo "merged=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            git commit -m "chore: merge dev → staging [$(date +'%Y-%m-%d')]"
          fi
                    
          git push origin staging
          echo "merged=true" >> $GITHUB_OUTPUT
          echo "✅ Successfully merged dev to staging"

      - name: Staging Sanity Check - Verify Embeddings
        if: steps.merge.outputs.merged == 'true'
        shell: bash
        run: |
          echo "Running sanity check on merged staging code..."
          npm run embed-all
          
          # Check if embeddings changed
          if git diff --quiet; then
            echo "✅ Embeddings are up-to-date on staging"
          else
            echo "::error::Embeddings are out-of-date on staging! This should not happen."
            echo "Modified files:"
            git diff --name-only
            exit 1
          fi

      - name: Verify test results from dev CI
        if: steps.merge.outputs.merged == 'true'
        run: |
          if [ ! -d ./test-results ]; then
            echo "::error::Test results artifacts missing from dev CI"
            exit 1
          fi
          echo "✅ Test artifacts verified from dev CI build"

      - name: Tag pre-release from staging
        if: steps.merge.outputs.merged == 'true'
        run: |
          VERSION=${{ steps.version.outputs.version }}
          PRERELEASE_TAG="v${VERSION}-pre"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # create or update pre-release tag pointing to staging HEAD
          git tag -f "$PRERELEASE_TAG"
          git push origin "$PRERELEASE_TAG" --force
          echo "✅ Tagged pre-release: $PRERELEASE_TAG"

      - name: Create/Update GitHub Pre-release
        if: steps.merge.outputs.merged == 'true'
        uses: ncipollo/release-action@v1
        with:
          tag: v${{ steps.version.outputs.version }}-pre
          name: v${{ steps.version.outputs.version }}-pre
          prerelease: true
          draft: false
          allowUpdates: true
          artifacts: ./vsix-artifact/*.vsix
          body: |
            ## Pre-release v${{ steps.version.outputs.version }}-pre
            Auto-published from staging merge.

      - name: Comment on merge failure
        if: failure()
        run: |
          echo "::warning::Auto-merge failed. Manual merge required."
          echo "Review the workflow run and resolve conflicts manually."
