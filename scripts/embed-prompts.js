#!/usr/bin/env node
/**
 * Build script to embed prompt files into promptStore.ts
 * 
 * Reads all *.prompt.md files from the prompts/ folder,
 * base64 encodes them, and regenerates promptStore.ts
 * 
 * Usage: node scripts/embed-prompts.js
 * Or via npm: npm run embed-prompts
 */

const fs = require('fs');
const path = require('path');

const PROMPTS_DIR = path.resolve(__dirname, '../prompts');
const OUTPUT_FILE = path.resolve(__dirname, '../src/promptStore.ts');

/**
 * Derive a clean ID from filename
 * e.g., "Checkpoint.prompt.md" -> "checkpoint"
 * e.g., "GH.prompt.md" -> "githubActions"
 */
function deriveId(filename) {
  const base = filename.replace(/\.prompt\.md$/, '').toLowerCase();
  // Special cases for better IDs
  const idMap = {
    'gh': 'githubActions',
    'sync': 'sync'
  };
  return idMap[base] || base;
}

/**
 * Derive a display title from filename
 * e.g., "Checkpoint.prompt.md" -> "Checkpoint"
 * e.g., "GH.prompt.md" -> "GH Actions"
 */
function deriveTitle(filename) {
  const base = filename.replace(/\.prompt\.md$/, '');
  const titleMap = {
    'GH': 'GH Actions'
  };
  return titleMap[base] || base;
}

/**
 * Read all prompt files and return metadata array
 */
function readPromptFiles() {
  const files = fs.readdirSync(PROMPTS_DIR)
    .filter(f => f.endsWith('.prompt.md'))
    .sort();

  console.log(`Found ${files.length} prompt files:`);
  
  return files.map(filename => {
    const filepath = path.join(PROMPTS_DIR, filename);
    const content = fs.readFileSync(filepath, 'utf8');
    const base64 = Buffer.from(content).toString('base64');
    
    const id = deriveId(filename);
    const title = deriveTitle(filename);
    
    console.log(`  - ${filename} (${id}) [${content.length} bytes -> ${base64.length} base64]`);
    
    return { id, filename, title, base64 };
  });
}

/**
 * Generate the TypeScript source code
 */
function generateTypeScript(prompts) {
  const promptsJson = prompts.map(p => `  {
    id: '${p.id}',
    filename: '${p.filename}',
    title: '${p.title}',
    base64: '${p.base64}'
  }`).join(',\n');

  return `// Note: 'vscode' is imported lazily inside loadWorkspacePrompts to allow this module to be required
// in Node environments (e.g. scripts/verify.js) where the vscode module is not available.
//
// AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
// Generated by: npm run embed-prompts
// Source: ai-skeleton-extension/prompts/*.prompt.md

export interface Prompt {
  id: string;
  filename: string;
  title: string;
  content: string;
}

interface EmbeddedPromptMeta { id: string; filename: string; title: string; base64: string; }

// Embedded (baked) prompt data captured at build time from prompts/
const embeddedPromptsData: EmbeddedPromptMeta[] = [
${promptsJson}
];

function decode(meta: EmbeddedPromptMeta): Prompt {
  const raw = Buffer.from(meta.base64.replace(/\\n/g, ''), 'base64').toString('utf8');
  return { id: meta.id, filename: meta.filename, title: meta.title, content: raw };
}

async function loadWorkspacePrompts(): Promise<Prompt[]> {
  try {
    const vscode = await import('vscode');
    const files = await vscode.workspace.findFiles('**/.github/prompts/*.prompt.md', '**/node_modules/**');
    if (!files.length) return [];
    const prompts: Prompt[] = [];
    for (const uri of files) {
      const buf = await vscode.workspace.fs.readFile(uri);
      const text = buf.toString();
      const filename = uri.path.split('/').pop() || 'prompt.md';
      const id = filename.replace(/\\.prompt\\.md$/,'').toLowerCase();
      // Derive title from first markdown heading if present
      const headingMatch = text.match(/^#\\s*(.+)$/m);
      const title = headingMatch ? headingMatch[1].trim() : filename.replace(/\\.prompt\\.md$/,'');
      prompts.push({ id, filename, title, content: text });
    }
    return prompts;
  } catch (e) {
    console.error('Failed to load workspace prompts', e);
    return [];
  }
}

export async function getPrompts(source: 'auto'|'embedded'|'workspace'): Promise<Prompt[]> {
  let chosen = source;
  if (source === 'auto') {
    const wsPrompts = await loadWorkspacePrompts();
    if (wsPrompts.length) return wsPrompts;
    chosen = 'embedded';
  }
  if (chosen === 'workspace') {
    const wsPrompts = await loadWorkspacePrompts();
    if (wsPrompts.length) return wsPrompts; // fallback
  }
  return embeddedPromptsData.map(decode);
}
`;
}

// Main execution
console.log('\\nüîß Embedding prompts into promptStore.ts...\\n');

try {
  const prompts = readPromptFiles();
  const tsCode = generateTypeScript(prompts);
  
  fs.writeFileSync(OUTPUT_FILE, tsCode, 'utf8');
  
  console.log(`\\n‚úÖ Successfully generated ${OUTPUT_FILE}`);
  console.log(`   Embedded ${prompts.length} prompts\\n`);
} catch (error) {
  console.error('\\n‚ùå Error embedding prompts:', error.message);
  process.exit(1);
}
